# Source: git diff (unstaged)
diff --git a/agents/v2-commands/didyouknow-v2.md b/agents/v2-commands/didyouknow-v2.md
index 65280b6..bea88cd 100644
--- a/agents/v2-commands/didyouknow-v2.md
+++ b/agents/v2-commands/didyouknow-v2.md
@@ -68,6 +68,7 @@ Build shared understanding between human and AI. In **default mode**, surface no
 - **Security & Privacy** ‚Äî exposed data, auth gaps, vulnerabilities?
 - **Deployment & Operations** ‚Äî coordination needed, rollback risks?
 - **Domain Boundaries** ‚Äî are concepts in the right domain? Reaching into another domain's internals? Missing contract? Duplicating something in another domain? Wrong dependency direction?
+- **Concept Documentation** ‚Äî are domain concepts discoverable? Missing `¬ß Concepts` section in domain.md? Stale concepts that no longer match implementation? Concept reuse opportunity across domains? Related contracts scattered across domains that should be unified under one concept?
 
 **Domain insights are not mandatory.** They surface when genuinely relevant. If domains are clean, they may not make the top 5. That's fine.
 
diff --git a/agents/v2-commands/plan-3-v2-architect.md b/agents/v2-commands/plan-3-v2-architect.md
index 64c3eda..684d1d1 100644
--- a/agents/v2-commands/plan-3-v2-architect.md
+++ b/agents/v2-commands/plan-3-v2-architect.md
@@ -38,7 +38,7 @@ Inputs:
 - If `docs/domains/registry.md` exists ‚Üí read all registered domains
 - If `docs/domains/domain-map.md` exists ‚Üí read the domain architecture diagram to understand current relationships and contract flows
 - For each existing domain in spec's target list ‚Üí read `docs/domains/<slug>/domain.md`
-  * Note: contracts (what's available to use), composition (what exists), dependencies
+  * Note: concepts (what the domain offers ‚Äî ¬ß Concepts table), contracts (what's available to use), composition (what exists), dependencies
 - For each NEW domain ‚Üí note the sketch from spec (Purpose, Boundary Owns/Excludes)
 
 ## PHASE 1: Gates
@@ -85,8 +85,9 @@ Check:
 2. Codebase patterns relevant to this feature
 3. Integration points where new code connects to existing code
 4. **Anti-reinvention**: Does any capability being planned already exist in a domain?
+   Check `¬ß Concepts` tables across all domains ‚Äî scan for concept names, entry points, and descriptions that match planned capabilities. A concept match is higher confidence than a code-level match.
 
-For each proposed new component, check domain contracts:
+For each proposed new component, check domain contracts and concepts:
 - EXISTING ‚Üí reuse (report contract and location)
 - EXTEND ‚Üí add to existing domain (report what to extend)
 - NEW ‚Üí create fresh (confirm no duplication)
diff --git a/agents/v2-commands/plan-4-v2-complete-the-plan.md b/agents/v2-commands/plan-4-v2-complete-the-plan.md
index 2b580d9..11de4a4 100644
--- a/agents/v2-commands/plan-4-v2-complete-the-plan.md
+++ b/agents/v2-commands/plan-4-v2-complete-the-plan.md
@@ -83,6 +83,7 @@ Inputs: PLAN_PATH, SPEC_PATH (co-located as `<plan-dir>/<slug>-spec.md>`), rules
 - If domain map exists: plan's new domains and relationships are consistent with map topology
 - No circular business-domain dependencies introduced
 - Consumed domains (relationship: consume) have contracts identified
+- NEW domains with contracts have `¬ß Concepts` section planned (concepts should be identified during extraction or implementation)
 
 **Report** (JSON):
 ```json
diff --git a/agents/v2-commands/plan-5-v2-phase-tasks-and-brief.md b/agents/v2-commands/plan-5-v2-phase-tasks-and-brief.md
index 4fe00e6..59c26b0 100644
--- a/agents/v2-commands/plan-5-v2-phase-tasks-and-brief.md
+++ b/agents/v2-commands/plan-5-v2-phase-tasks-and-brief.md
@@ -147,10 +147,11 @@ Otherwise ‚Üí **Phase Mode** (continue).
    **Key findings from plan**:
    - [Finding N: brief + action required]
 
-   **Domain dependencies** (contracts this phase consumes ‚Äî from `docs/domains/domain-map.md`):
-   - `[domain]`: [contract name] ‚Äî [what we use it for]
-   - Example: `_platform`: ILogger ‚Äî logging throughout new service
-   - Example: `auth`: IAuthService.authenticate() ‚Äî verify user before processing
+   **Domain dependencies** (concepts and contracts this phase consumes ‚Äî from `docs/domains/*/domain.md`):
+   - `[domain]`: [Concept Name] ([entry point]) ‚Äî [what we use it for]
+   - Example: `_platform/events`: File change subscription (useFileChanges) ‚Äî live file updates in tree
+   - Example: `_platform/state`: Read single state value (useGlobalState) ‚Äî workflow status display
+   - Example: `auth`: User authentication (IAuthService.authenticate()) ‚Äî verify user before processing
 
    **Domain constraints**:
    - [Import rules, dependency direction, contract boundaries]
diff --git a/agents/v2-commands/plan-6-v2-implement-phase.md b/agents/v2-commands/plan-6-v2-implement-phase.md
index 72739d1..016e489 100644
--- a/agents/v2-commands/plan-6-v2-implement-phase.md
+++ b/agents/v2-commands/plan-6-v2-implement-phase.md
@@ -162,6 +162,20 @@ $ARGUMENTS
       - New cross-domain dependency formed ‚Üí add labeled edge
       - Domain contracts changed ‚Üí update the Health Summary table
 
+   h) **Update domain.md ¬ß Concepts** (if contracts changed or new domain):
+
+      For NEW domains:
+        - Create Concepts table from implemented contracts
+        - Group related contracts into named concepts (verb phrases)
+        - Add narrative + code example per concept (base on actual implemented code)
+
+      For CHANGED contracts:
+        - Add new concepts to table if new capabilities introduced
+        - Update existing concept narratives if entry points changed
+        - Update code examples to match new signatures
+
+      For UNCHANGED contracts: no Concepts updates needed.
+
 5) Output:
    - Execution Log with per-task entries (write incrementally)
    - Unified diffs for all touched files
diff --git a/agents/v2-commands/plan-6a-v2-update-progress.md b/agents/v2-commands/plan-6a-v2-update-progress.md
index 7e712cc..1c89dff 100644
--- a/agents/v2-commands/plan-6a-v2-update-progress.md
+++ b/agents/v2-commands/plan-6a-v2-update-progress.md
@@ -52,6 +52,8 @@ $ARGUMENTS
    - Note any new components added to domain composition
    - Note any contract changes
    - Flag if `docs/domains/domain-map.md` needs updating (new contracts, new edges, new domains)
+   - If contract changes recorded ‚Üí flag "domain.md ¬ß Concepts update needed for <domain>"
+   - If new domain created ‚Üí flag "domain.md ¬ß Concepts creation needed for <domain>"
 
 7) Report what was updated.
 ```
diff --git a/agents/v2-commands/plan-7-v2-code-review.md b/agents/v2-commands/plan-7-v2-code-review.md
index 86d4a45..4f544a4 100644
--- a/agents/v2-commands/plan-7-v2-code-review.md
+++ b/agents/v2-commands/plan-7-v2-code-review.md
@@ -113,10 +113,11 @@ Launch **5 subagents** in parallel (single message with 5 Task tool calls):
 7. **Map currency**: docs/domains/domain-map.md reflects all domains, new edges labeled, contracts in node labels current, health summary table current
 8. **No circular business deps**: No business‚Üíbusiness cycles in the domain map
 9. **No unlabeled edges**: Every dependency on the map has a contract label
+10. **Concepts documentation** (‚ö†Ô∏è Review): Domains with contracts have a `¬ß Concepts` section in domain.md. Level 1 minimum: table with Concept | Entry Point | What It Does. New contracts added in this phase appear in the Concepts table.
 
 **Output** (JSON array):
 ```json
-[{\"severity\": \"HIGH|MEDIUM|LOW\", \"check\": \"file-placement|contract-imports|dependency-direction|domain-md|registry|orphan|map-nodes|map-edges|circular-deps\", \"file\": \"...\", \"issue\": \"...\", \"fix\": \"...\"}]
+[{\"severity\": \"HIGH|MEDIUM|LOW\", \"check\": \"file-placement|contract-imports|dependency-direction|domain-md|registry|orphan|map-nodes|map-edges|circular-deps|concepts-docs\", \"file\": \"...\", \"issue\": \"...\", \"fix\": \"...\"}]
 ```"
 
 ### Subagent 3: Anti-Reinvention Check
@@ -277,6 +278,7 @@ Universal (all approaches):
 | Map nodes current | ‚úÖ/‚ùå | |
 | Map edges current | ‚úÖ/‚ùå | |
 | No circular business deps | ‚úÖ/‚ùå | |
+| Concepts documented | ‚úÖ/‚ö†Ô∏è/N/A | |
 
 ### E.3) Anti-Reinvention
 
diff --git a/agents/v2-commands/plan-v2-extract-domain.md b/agents/v2-commands/plan-v2-extract-domain.md
index 4123efd..a81d495 100644
--- a/agents/v2-commands/plan-v2-extract-domain.md
+++ b/agents/v2-commands/plan-v2-extract-domain.md
@@ -108,6 +108,32 @@ Ask the user to confirm/adjust using the ask_user tool:
 
 **Key principle**: The agent proposes, the user decides. Domain boundary identification is a collaborative conversation.
 
+## Step 3.5: Identify Concepts
+
+Group discovered contracts (from Subagent 2) into **named concepts** ‚Äî consumer-facing capabilities that the domain offers. Each concept groups related contracts into one capability a consumer might search for.
+
+For each concept, identify:
+- **Concept name**: A verb phrase describing what consumers can do (e.g., "Subscribe to file changes", "Authenticate a user")
+- **Entry point**: The primary contract/function a consumer imports first
+- **What it does**: One sentence describing the capability
+
+**Grouping rules**:
+- Related contracts that serve one consumer use case = one concept
+- A single contract can be its own concept if it's independently useful
+- All concepts that a consumer might search for get a row ‚Äî not limited to a "top 3"
+
+Present the proposed concepts to the user for confirmation:
+
+```
+Based on the contracts discovered, I'd group them into these concepts:
+
+| Concept | Entry Point | What It Does |
+|---------|-------------|-------------|
+| [verb phrase] | [primary contract] | [one line] |
+```
+
+Ask: "Do these concepts cover everything this domain offers? Should any be split, merged, or renamed?"
+
 ## Step 4: Write Domain Files
 
 ### 4a: Create domain.md
@@ -128,6 +154,26 @@ Create `docs/domains/<slug>/domain.md` (mkdir -p the directory):
 [1-3 sentences from user discussion: What business concept does this domain own?
 Why does it exist? What would break if it didn't?]
 
+## Concepts
+
+[What this domain offers to consumers. Scannable table + narrative per concept.
+Built from Step 3.5 ‚Äî the confirmed concept groupings.]
+
+| Concept | Entry Point | What It Does |
+|---------|-------------|-------------|
+| [verb phrase from Step 3.5] | [primary contract/function] | [one line description] |
+
+### [Concept Name]
+
+[2-3 sentences: When would a consumer use this? What's the pattern?]
+
+‚Äã```[language]
+import { EntryPoint } from '@domains/[slug]';
+// 3-5 line usage example showing the happy path
+‚Äã```
+
+[Repeat for each concept identified in Step 3.5]
+
 ## Boundary
 
 ### Owns
@@ -177,6 +223,7 @@ Primary: `[most common path prefix, or "scattered"]`
 
 **Required sections** (plan-7 validates these exist):
 - Purpose
+- Concepts (‚ö†Ô∏è Review if missing when contracts exist)
 - Boundary (Owns + Does NOT Own)
 - Contracts
 - Composition

# Source: git diff --staged

# Source: untracked file diffs

## Untracked: agents/v2-commands/code-concept-search-v2.md
diff --git a/agents/v2-commands/code-concept-search-v2.md b/agents/v2-commands/code-concept-search-v2.md
new file mode 100644
index 0000000..329a0ee
--- /dev/null
+++ b/agents/v2-commands/code-concept-search-v2.md
@@ -0,0 +1,479 @@
+---
+description: Find a concept in the codebase by walking through code like a human engineer ‚Äî even when it's named differently than expected. V2 with domain Concepts table scanning as first search layer. Returns provenance, usage, and reuse assessment.
+---
+
+Please deep think / ultrathink as this is a nuanced search and exploration task.
+
+# code-concept-search-v2
+
+Find a **concept** in the codebase ‚Äî a pattern, a capability, a component, a method ‚Äî even when the codebase names it something completely different from what you expect. Returns factual findings with provenance (which plan created it, who modified it, why it exists) so callers can make informed reuse decisions.
+
+**V2 Enhancement**: Scans domain `¬ß Concepts` tables first for near-instant discovery before falling through to code-level search. Domain Concepts are a structured capability index ‚Äî if a domain documents a concept, we find it in seconds, not minutes.
+
+**Key Characteristics**:
+- **Domain-Concepts-first** ‚Äî scans `docs/domains/*/domain.md` ¬ß Concepts tables as Tier 0
+- **IS the worker** (does NOT launch subagents)
+- **FlowSpace-first** with multi-tier fallback
+- **Walks the codebase like a human engineer** when FlowSpace is unavailable ‚Äî reads, follows flows, reasons about what's related
+- **Provenance-aware** ‚Äî traces each finding back through plans, execution logs, and git history
+- **Concise output** ‚Äî all the facts, no filler
+
+---
+
+## Input Parameters
+
+```
+$ARGUMENTS
+# Required:
+#   <concept>            What to find (positional, required)
+#
+# Optional:
+#   --scope <path>       Limit search to path (e.g., "src/services/")
+#   --exclude <pattern>  Exclude paths matching pattern (e.g., "test,vendor")
+#   --limit <N>          Max findings to return (default: 5)
+#   --provenance         Include full plan provenance for each finding (default: true)
+#   --no-provenance      Skip provenance lookup (faster, for quick checks)
+#   --skip-domains       Skip Tier 0 domain scan (go straight to code search)
+#
+# Examples:
+#   /code-concept-search-v2 "rate limiter"
+#   /code-concept-search-v2 "file change subscription"
+#   /code-concept-search-v2 "connectNode" --scope "src/graph/"
+#   /code-concept-search-v2 "logger" --no-provenance
+#   /code-concept-search-v2 "authentication middleware"
+```
+
+---
+
+## Execution Flow
+
+### 1) Understand the Concept
+
+Before searching, reason about the concept to guide exploration:
+
+```
+Given concept: "<CONCEPT>"
+
+Think:
+- What KIND of thing is this? (class, function, pattern, service, utility, data structure)
+- What DOMAIN does it belong to? (auth, graph, networking, UI, data processing, logging)
+- What PROBLEM does it solve? (connecting things, caching, validating, transforming)
+- What NAMES might it have? (not synonyms from a thesaurus ‚Äî names a developer would actually use)
+- What PATTERNS typically implement this? (middleware, decorator, factory, singleton, strategy)
+- Where in a typical project would this LIVE? (services/, utils/, middleware/, core/, lib/)
+```
+
+This reasoning step is critical. It turns a keyword search into a directed exploration.
+
+### 2) Domain & FlowSpace Detection
+
+```python
+# Check for domain documentation
+DOMAINS_AVAILABLE = exists("docs/domains/registry.md") or glob("docs/domains/*/domain.md")
+
+try:
+    flowspace.tree(pattern=".", max_depth=1)
+    FLOWSPACE_AVAILABLE = True
+
+    try:
+        flowspace.search(pattern="test", mode="semantic", limit=1)
+        SEMANTIC_AVAILABLE = True
+    except:
+        SEMANTIC_AVAILABLE = False
+
+except:
+    FLOWSPACE_AVAILABLE = False
+    SEMANTIC_AVAILABLE = False
+```
+
+### 3) Search (Tiered)
+
+Execute the appropriate search tier based on available tools. **Try each tier in order. Stop when you have sufficient results.**
+
+---
+
+#### Tier 0: Domain Concepts Scan (fastest, highest confidence)
+
+**Prerequisite**: DOMAINS_AVAILABLE and not --skip-domains
+
+```
+1. Find all domain.md files: docs/domains/*/domain.md (including nested like docs/domains/_platform/*/domain.md)
+
+2. For each domain.md, scan ¬ß Concepts table:
+   - Match concept name, entry point, or "What It Does" column against the search query
+   - Use fuzzy matching ‚Äî "file changes" should match "File change subscription"
+   - Also check concept narrative subsections for relevant keywords
+
+3. If no ¬ß Concepts match, fall through to ¬ß Contracts table:
+   - Match contract name or description column
+   - This is lower confidence ‚Äî the contract exists but may lack usage guidance
+
+4. For each match, read the concept narrative (if present) for:
+   - Entry point (the import/function a consumer uses)
+   - Code example (if included in narrative)
+   - The domain slug and domain purpose
+```
+
+**Output per match**:
+```
+üì¶ Domain Concept Match (high confidence):
+  Domain: <slug>
+  Concept: <concept name from table>
+  Entry Point: <entry point from table>
+  What It Does: <description from table>
+  SDK Guidance: <concept narrative if present, or "See domain.md ¬ß Concepts">
+```
+
+**If Tier 0 finds sufficient matches**: Report them and STOP (unless caller wants more depth). These are documented, named, consumer-facing capabilities ‚Äî the highest confidence match possible.
+
+**If Tier 0 finds nothing or partial results**: Continue to Tier 1.
+
+---
+
+#### Tier 1: FlowSpace Semantic Search (best code-level search)
+
+**Prerequisite**: FLOWSPACE_AVAILABLE and SEMANTIC_AVAILABLE
+
+```python
+results = flowspace.search(
+    pattern=concept,
+    mode="semantic",
+    limit=limit * 2,  # Over-fetch, filter later
+    detail="max"
+)
+
+# Also search with decomposed terms if concept is multi-word
+if " " in concept:
+    for term in concept.split():
+        more = flowspace.search(pattern=term, mode="semantic", limit=5)
+        results.extend(more)
+
+# Get full source for top results
+for result in deduplicate(results)[:limit]:
+    node = flowspace.get_node(node_id=result["node_id"], detail="max")
+    findings.append(node)
+```
+
+Semantic search finds conceptually related code even when names differ completely. This is the only tier that can find "elementConnector" from a query of "connectNode" without decomposition.
+
+---
+
+#### Tier 2: FlowSpace Text + Tree (semantic unavailable)
+
+**Prerequisite**: FLOWSPACE_AVAILABLE, not SEMANTIC_AVAILABLE
+
+```python
+# Search by the concept terms
+results = flowspace.search(pattern=concept, mode="text", limit=limit * 3)
+
+# Also search by decomposed terms
+terms = decompose_concept(concept)  # "connectNode" ‚Üí ["connect", "node"]
+for term in terms:
+    more = flowspace.search(pattern=term, mode="text", limit=10)
+    results.extend(more)
+
+# Use tree to find symbols in likely directories
+likely_dirs = identify_likely_directories(concept)  # From step 1 reasoning
+for dir in likely_dirs:
+    tree_results = flowspace.tree(pattern=dir, max_depth=2, detail="max")
+    # Scan tree output for related symbols
+```
+
+Better than raw grep because FlowSpace indexes symbols and understands code structure. But still string matching ‚Äî won't find semantic synonyms.
+
+---
+
+#### Tier 3: Codebase Walk-Through (no FlowSpace)
+
+**Prerequisite**: FLOWSPACE not available. This is the critical tier.
+
+**Do NOT just grep for synonyms.** Walk the codebase like a human engineer would:
+
+**Phase A: Orient ‚Äî understand the project structure**
+```
+1. Read top-level directory listing (ls or Glob at root)
+2. Identify relevant directories based on step 1 reasoning:
+   - What domain does the concept belong to? Find that domain's directory.
+   - Where would this kind of thing typically live? (services/, utils/, middleware/, core/)
+3. Read any README, index, or __init__ files in candidate directories
+4. Build a mental map of the project's architecture from what you see
+```
+
+**Phase B: Explore ‚Äî follow the flow**
+```
+5. For each candidate directory:
+   a. List its contents (Glob)
+   b. Read filenames ‚Äî do any suggest the concept? (not just exact match ‚Äî
+      a file called "throttle.py" IS a rate limiter)
+   c. Read the most promising files ‚Äî scan for classes, functions, patterns
+      that DO what the concept DOES, regardless of what they're CALLED
+   d. Follow imports ‚Äî if you find something adjacent, trace where it comes
+      from and what else uses it
+   e. Read docstrings, comments, type signatures ‚Äî these often describe the
+      concept in plain English even when the code name is opaque
+
+6. If the concept is workflow-related or architectural:
+   a. Follow the request/data flow from entry point
+   b. Read middleware chains, pipeline stages, event handlers
+   c. Trace the execution path ‚Äî the concept might be embedded in a larger
+      flow rather than being a standalone component
+```
+
+**Phase C: Verify ‚Äî confirm or rule out candidates**
+```
+7. For each candidate found:
+   a. Read the full implementation (not just the signature)
+   b. Does it actually do what the concept describes? (not just name similarity)
+   c. Check its consumers ‚Äî who calls it? This reveals its actual role.
+   d. Check its scope ‚Äî is it general-purpose or tightly coupled to one feature?
+
+8. If nothing found after exploring obvious locations:
+   a. Try broader Grep for the concept's VERB (what it does: "connect", "limit", "cache")
+   b. Read the results in context ‚Äî follow up on anything promising
+   c. Check if the concept might be handled by an external library instead of custom code
+```
+
+**Phase D: Targeted Grep (last resort within Tier 3)**
+```
+9. If walk-through hasn't found it, fall back to targeted searches:
+   a. Grep for class/function definitions with concept terms:
+      - Decompose: "connectNode" ‚Üí ["connect", "node"]
+      - Grep: "class.*[Cc]onnect", "def.*connect", "function.*connect"
+      - Grep: "class.*[Nn]ode", "class.*[Ll]ink", "class.*[Ww]ire"
+   b. Grep for common implementation patterns:
+      - "rate limiter" ‚Üí grep for "token.bucket", "sliding.window", "throttl", "rate.limit"
+      - "logger" ‚Üí grep for "getLogger", "createLogger", "OutputChannel", "winston", "pino"
+      - "cache" ‚Üí grep for "TTL", "LRU", "invalidat", "memoiz"
+   c. Search docs/ and comments for the concept in plain English
+```
+
+The key insight: **the agent's reasoning IS the search engine**. Grep is just one tool the agent uses while walking through code. The agent reads, thinks, follows leads, and makes judgments ‚Äî exactly like a human engineer.
+
+---
+
+#### Tier 4: Confirm Not Found
+
+If all tiers return nothing:
+```
+Report:
+- Concept: "<CONCEPT>"
+- Search mode: [which tiers were attempted]
+- Domain scan: [domains checked, or "no domains registered"]
+- Directories explored: [list]
+- Grep patterns tried: [list]
+- Result: No matching concept found in codebase
+- Assessment: Safe to create ‚Äî no existing implementation to reuse or conflict with
+```
+
+This is a **valid and useful result**. Confirming absence is as valuable as finding presence.
+
+---
+
+### 4) Provenance Lookup (unless --no-provenance)
+
+For each concept found, trace its history through the plan system:
+
+```
+For each finding:
+
+1. ORIGIN PLAN:
+   - Extract file path from the finding
+   - Search docs/plans/*/execution.log.md for the file path
+     (grep both absolute and relative forms; paths may be backtick-wrapped)
+   - Search docs/plans/*-plan.md task tables for the path in Absolute Path(s) columns
+   - If file lives in features/<ordinal>-<slug>/ (PlanPak): the ordinal IS the origin plan
+   - Fallback: git log --follow --diff-filter=A -- <filepath> for creation commit
+
+2. MODIFICATION HISTORY:
+   - Same sources as origin, collect ALL plan references
+   - git log --oneline -- <filepath> for commit history
+
+3. WHY IT EXISTS:
+   - Find the execution log entry for the task that created it
+   - Extract the "What I Did" or "Changes Made" section
+   - This gives the rationale ‚Äî why was this built, what problem did it solve?
+
+4. ORIGINAL INTENT:
+   - Read the plan's spec (docs/plans/<ordinal>-<slug>/<slug>-spec.md) for the feature goals
+   - Read the plan's task description that created this file ‚Äî what was the task trying to achieve?
+   - Read any relevant ADR that governed the design choice
+   - Synthesize into a paragraph: what was the plan's intent for this code?
+     What role was it meant to play? What constraints was it designed under?
+   - This lets the caller check vibe alignment ‚Äî "am I about to use this for
+     something the original author never intended?"
+
+5. CURRENT CONSUMERS:
+   - Grep for imports/requires of the file or symbol
+   - Count how many files use this concept
+   - Note if usage is concentrated (one feature) or widespread (shared utility)
+```
+
+### 5) Generate Output
+
+```markdown
+## Concept Search: "<CONCEPT>"
+
+**Query**: <original concept>
+**Search mode**: <Domain Concepts | FlowSpace semantic | FlowSpace text | Codebase walk-through | Targeted grep>
+**Scope**: <path filter or "ÂÖ® codebase">
+**Results**: <N> concept(s) found
+
+---
+
+### üì¶ Domain Concept: <Concept Name> ‚Äî <domain slug>
+
+**Match quality**: Domain Documented
+**Domain**: <slug> (<type>)
+**Entry Point**: `<entry point from Concepts table>`
+**What It Does**: <description from Concepts table>
+**Guidance**: <concept narrative or "See docs/domains/<slug>/domain.md ¬ß Concepts">
+
+**Usage example** (from domain docs):
+```<language>
+<code example from concept narrative, if available>
+```
+
+**Provenance**:
+- **Domain created by**: Plan <NNN>-<slug>
+- **Concept added by**: Plan <NNN>-<slug>
+
+**Consumers**: <domains listed in domain.md ¬ß Contracts for this entry point>
+**Reuse assessment**: REUSE ‚Äî this capability is documented and published by the <slug> domain. Import from its public contracts.
+
+---
+
+### 1. <SymbolName> ‚Äî <file:line>
+
+**Match quality**: <Exact | Strong | Related | Weak>
+**What it is**: <class | function | module | pattern | service>
+**What it does**: <1-2 sentence factual description of what this code does>
+**Signature**: `<function/class signature>`
+
+**Provenance**:
+- **Created by**: Plan <NNN>-<slug> (T<XXX>) | Pre-plan | Unknown
+- **Modified by**: Plan <NNN> (T<XXX>), Plan <MMM> (T<YYY>) | None
+- **Why it exists**: <1-2 sentences from execution log explaining the rationale>
+
+**Original intent**: <Paragraph describing what the originating plan intended this
+  code to do. What role does it play in the feature? What problem was it designed
+  to solve? What constraints or design decisions shaped it? Sourced from the plan
+  spec, task description, and any governing ADR. This is the "vibe check" ‚Äî does
+  your intended use align with why this was built?>
+
+**Usage**: <N> files import/call this
+**Scope**: <General-purpose utility | Feature-specific | Tightly coupled>
+
+**Reuse assessment**: <1-2 sentences ‚Äî is this appropriate for the caller's purpose?
+  Factor in the original intent: if the caller's use diverges from the original
+  design intent, flag that as a risk even if the code technically works. Consider:
+  is it general enough? Is it in the right layer? Would extending it preserve or
+  break the original intent?>
+
+---
+
+### No Further Matches
+
+<If fewer than limit results: briefly note what was searched and why no more were found>
+```
+
+---
+
+## Output Rules
+
+- **Domain Concept matches rank highest**: Always list before code-level findings
+- **Factual, not verbose**: Every sentence must convey a fact. No filler, no hedging, no "it appears that."
+- **All findings ranked**: Best match first, weakest last
+- **Match quality labels**:
+  - **Domain Documented**: Concept exists in a domain's ¬ß Concepts table (highest confidence)
+  - **Exact**: Name matches the concept directly
+  - **Strong**: Different name but clearly implements the same concept
+  - **Related**: Adjacent concept ‚Äî might be reusable with modification
+  - **Weak**: Tangentially related ‚Äî noted for awareness, not reuse
+- **Provenance included by default**: Skip only with `--no-provenance`
+- **Reuse assessment is opinionated**: The command should say "yes, reuse this" or "no, this is too coupled" ‚Äî not "it depends"
+- **Cap at limit results**: Default 5. Caller can increase if needed.
+
+---
+
+## Decomposition Helper
+
+When breaking a concept into searchable terms:
+
+```python
+def decompose_concept(concept):
+    """
+    Break a concept into searchable components.
+
+    "connectNode"  ‚Üí ["connect", "node"]
+    "rate limiter" ‚Üí ["rate", "limiter"]
+    "AuthService"  ‚Üí ["auth", "service"]
+    "token_bucket" ‚Üí ["token", "bucket"]
+    """
+    # Split on spaces
+    if " " in concept:
+        return [w.lower() for w in concept.split() if len(w) > 2]
+
+    # Split camelCase: "connectNode" ‚Üí ["connect", "Node"]
+    parts = re.findall(r'[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)', concept)
+
+    # Split snake_case: "token_bucket" ‚Üí ["token", "bucket"]
+    if "_" in concept:
+        parts = concept.split("_")
+
+    return [p.lower() for p in parts if len(p) > 2]
+```
+
+This is used for targeted grep patterns, NOT as the primary search strategy. The primary strategy is domain Concepts tables ‚Üí semantic search ‚Üí human-like walk-through.
+
+---
+
+## Integration Points
+
+This command is designed to be called by:
+- **plan-3-v2 Domain & Pattern Scout**: anti-reinvention check against domain Concepts tables
+- **Pre-Implementation Audit subagent** (plan-5 step 5a/S4): duplication check for new files
+- **plan-1a-v2-explore**: codebase research subagents checking for existing implementations
+- **Direct user invocation**: "does this thing already exist before I build it?"
+- **plan-6-v2**: mid-implementation discovery when agent encounters a concept that might exist elsewhere
+
+When called as a subagent, the structured output format allows parent commands to parse findings programmatically.
+
+---
+
+## Examples
+
+### Example 1: Domain Concept Hit
+```
+/code-concept-search-v2 "file change subscription"
+```
+Scans domain ¬ß Concepts tables. Finds "File change subscription" in `_platform/events` domain with entry point `useFileChanges`. Reports domain match with usage example. Stops ‚Äî no need to search code.
+
+### Example 2: Specific method
+```
+/code-concept-search-v2 "connectNode"
+```
+No domain match. Walks graph-related directories, finds `GraphBuilder.link()` and `NodeLinker.batch_connect()`.
+
+### Example 3: Broad concept
+```
+/code-concept-search-v2 "rate limiter"
+```
+No domain match. Checks middleware/, services/, utils/ for throttling patterns. Finds `TokenBucket` class in utils/throttle.py.
+
+### Example 4: Domain Contracts fallback
+```
+/code-concept-search-v2 "toast notifications"
+```
+No ¬ß Concepts match, but finds `toast()` in `_platform/events` domain ¬ß Contracts table. Reports as medium confidence. Recommends checking domain.md for usage guidance.
+
+### Example 5: Scoped search
+```
+/code-concept-search-v2 "authentication middleware" --scope "src/api/"
+```
+Walks only src/api/, follows middleware chain, finds `AuthGuard` decorator.
+
+### Example 6: Nothing found
+```
+/code-concept-search-v2 "GraphQL subscription handler"
+```
+Scans domain Concepts (none). Walks codebase, finds no GraphQL infrastructure. Reports: "No matching concept found. Safe to create."

## Untracked: docs/plans/016-domain-concepts/
