#!/usr/bin/env python3

"""
Generate convention-based aliases for scripts in the scripts/ directory.
Convention: First letter of each dash-separated word becomes the alias.
Example: generate-codebase-md.sh -> gcm
"""

import os
import sys
import subprocess
from pathlib import Path

def print_status(msg):
    print(f"[*] {msg}")

def print_success(msg):
    print(f"[✓] {msg}")

def print_error(msg):
    print(f"[✗] {msg}", file=sys.stderr)

def print_warning(msg):
    print(f"[!] {msg}")

def get_script_dir():
    """Get the directory where this script is located."""
    return Path(__file__).parent.resolve()

def get_scripts_path():
    """Get the scripts directory path."""
    return get_script_dir().parent / "scripts"

def generate_alias(script_name):
    """
    Generate an alias from a script name.
    Takes first letter of each dash-separated word.
    """
    # Remove extension
    name_without_ext = script_name.rsplit('.', 1)[0]
    
    # If no dashes, no alias needed
    if '-' not in name_without_ext:
        return None
    
    # Split by dash and take first letter of each part
    parts = name_without_ext.split('-')
    alias = ''.join(part[0].lower() for part in parts if part)
    
    return alias

def check_command_exists(cmd):
    """Check if a command already exists in the system."""
    try:
        subprocess.run(['which', cmd], capture_output=True, check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def get_existing_aliases():
    """Read existing aliases from ~/.tools_aliases."""
    aliases_file = Path.home() / ".tools_aliases"
    aliases = {}
    
    if aliases_file.exists():
        with open(aliases_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith('alias ') and '=' in line:
                    # Parse: alias name='command'
                    parts = line[6:].split('=', 1)
                    if len(parts) == 2:
                        alias_name = parts[0].strip()
                        alias_cmd = parts[1].strip().strip("'\"")
                        aliases[alias_name] = alias_cmd
    
    return aliases

def write_aliases(aliases_dict):
    """Write aliases to ~/.tools_aliases."""
    aliases_file = Path.home() / ".tools_aliases"
    
    with open(aliases_file, 'w') as f:
        f.write("# Auto-generated aliases for tools repository\n")
        f.write("# Generated by tools/install/aliases.py\n")
        f.write("# DO NOT EDIT - This file is auto-generated\n\n")
        
        # Sort aliases for consistent output
        for alias, command in sorted(aliases_dict.items()):
            f.write(f"alias {alias}='{command}'\n")

def ensure_sourced_in_zshrc():
    """Ensure ~/.tools_aliases is sourced in ~/.zshrc."""
    zshrc_path = Path.home() / ".zshrc"
    aliases_file = Path.home() / ".tools_aliases"
    source_line = f'[ -f "{aliases_file}" ] && source "{aliases_file}" # Tools repository aliases'
    
    # Read current .zshrc
    if zshrc_path.exists():
        with open(zshrc_path, 'r') as f:
            content = f.read()
        
        # Check if already sourced
        if str(aliases_file) in content:
            return False  # Already sourced
        
        # Add source line
        with open(zshrc_path, 'a') as f:
            f.write(f"\n{source_line}\n")
        return True
    else:
        # Create .zshrc with source line
        with open(zshrc_path, 'w') as f:
            f.write(f"{source_line}\n")
        return True

def main():
    print("======================================")
    print("      Aliases Generation Script       ")
    print("======================================")
    print()
    
    scripts_path = get_scripts_path()
    
    if not scripts_path.exists():
        print_error(f"Scripts directory not found: {scripts_path}")
        sys.exit(1)
    
    print_status(f"Scanning scripts in: {scripts_path}")
    
    # Get all executable files in scripts directory
    scripts = []
    for file in scripts_path.iterdir():
        if file.is_file() and os.access(file, os.X_OK):
            scripts.append(file.name)
    
    if not scripts:
        print_status("No executable scripts found")
        sys.exit(0)
    
    print_status(f"Found {len(scripts)} executable script(s)")
    print()
    
    # Generate aliases
    new_aliases = {}
    conflicts = []
    skipped = []
    
    for script in scripts:
        alias = generate_alias(script)
        
        if alias is None:
            skipped.append(script)
            continue
        
        # Check for conflicts with existing system commands
        if check_command_exists(alias):
            conflicts.append((script, alias))
            print_warning(f"Skipping {script} -> {alias} (command already exists)")
            continue
        
        new_aliases[alias] = script
        print_success(f"Creating alias: {alias} -> {script}")
    
    # Get existing aliases
    existing_aliases = get_existing_aliases()
    
    # Check what's changed
    added = set(new_aliases.keys()) - set(existing_aliases.keys())
    removed = set(existing_aliases.keys()) - set(new_aliases.keys())
    updated = {k for k in new_aliases.keys() & existing_aliases.keys() 
               if new_aliases[k] != existing_aliases[k]}
    
    # Write aliases if there are any
    if new_aliases:
        write_aliases(new_aliases)
        aliases_file = Path.home() / ".tools_aliases"
        print()
        print_success(f"Aliases written to: {aliases_file}")
        
        # Ensure sourced in .zshrc
        if ensure_sourced_in_zshrc():
            print_success("Added source line to ~/.zshrc")
        else:
            print_status("Aliases already sourced in ~/.zshrc")
    else:
        print()
        print_status("No aliases to create")
    
    # Print summary
    print()
    print("======================================")
    print_success("Alias generation complete!")
    print()
    print("Summary:")
    print(f"  • Created: {len(added)} new alias(es)")
    if updated:
        print(f"  • Updated: {len(updated)} alias(es)")
    if removed:
        print(f"  • Removed: {len(removed)} old alias(es)")
    if conflicts:
        print(f"  • Conflicts: {len(conflicts)} skipped")
    if skipped:
        print(f"  • No alias needed: {len(skipped)} script(s)")
    
    if new_aliases:
        print()
        print("To use the aliases in your current shell:")
        print("  source ~/.tools_aliases")
        print()
        print("Or open a new terminal window.")
    
    print("======================================")

if __name__ == "__main__":
    main()